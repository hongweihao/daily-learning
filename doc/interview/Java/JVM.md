### JVM
#### 1. JVM内存结构？

![JVM内存结构.png](http://ww1.sinaimg.cn/large/006fJlVugy1gcqeqx1x86j30vh0l4q4i.jpg)



#### 2. 简单可达性分析

GC回收的起点：`GC root` 

> 方法区中常量引用的对象
>
> 方法区中静态变量引用的对象
>
> 虚拟机栈中引用的对象
>
> 本地方法中引用的对象



一个对象与 `GCroot` 不存在任何引用链时，则此对象不可活，但是仍然能通过 `finalize()` 方法自救；一个对象被回收至少需要经过两个标记过程，在第二次标记前，需要判断是否有必要执行`finalize()`，如果判断为有必要执行，JVM会创建一个队列统一执行方法，在这段过程中有可能自救。

> 有必要执行 `finalize()` 的条件：重写过 `finalize()` 方法，且没被执行过



#### 3. Java中init方法与clinit方法

> <clinit>方法：Java文件被编译后，会在字节码文件中生成一个<clinit>方法，<clinit>方法是将静态变量初始化/静态语句块/构造方法收敛起来的一个方法。类加载的过程中执行。 

> <init> 方法：Java文件被编译后，会在字节码文件中生成一个<init>方法，<init>方法包括：变量初始化/语句块/构造方法。实例化对象的过程执行。 

根据类加载和对象实例化的顺序可以得到类中变量和语句块的执行顺序：

> 父类静态变量初始化 --> 父类静态语句块 --> 子类静态变量初始化 --> 子类静态语句块 --> 父类变量初始化 --> 父类语句块  --> 父类构造方法  --> 子类变量初始化  -->  子类语句块  --> 子类构造方法



#### 4. 垃圾回收算法

1. 标记清除算法

> 将待回收对象标记，然后统一清除，缺点是效率低，会产生大量碎片。

2. 复制算法

> 将一块内存区域分为两个部分，其中一个区域运行时被实际使用，另一个区域用作复制的目标。在一个区域中标记待回收对象，将存活对象复制到第二区域，然后清除待回收对象。优点是不会产生碎片空间，缺点是内存使用率低，相当于只有一个区域被实际使用。JVM中的年轻代使用这个算法。

3. 标记整理算法

> 标记待回收对象，将存活对象移动到一块连续的区域，回收待回收对象。JVM中老年代使用这个算法。

4. 分代回收算法

> JVM中分为老年代和年轻代。



#### 5. 垃圾回收器

[JVM系列(六) - JVM垃圾回收器](https://zhuanlan.zhihu.com/p/43892710)

> `serial`：单线程，新生代，复制算法(stop-the-world)
>
> `serial old`：单线程，老年代，标记整理算法(stop-the-world)
>
> `parNew`：多线程，新生代， 复制算法(stop-the-world)
>
> `parallel scanvege`：多线程， 新生代，复制算法(stop-the-world) 吞吐量
>
> `parallel old`：多线程，老年代，标记整理算法(stop-the-world)
>
> `CMS`：多线程，老年代，标记清除算法（不能清除浮动垃圾）
>
> `G1`：多线程，新/老年代，标记整理算法（局部是复制算法）



#### 6. GC类型

> `minorGC`：在年轻代中发生，频率高，当Eden/survivor(from/to)满时就会触发，空间不够会放入老年代。大对象（数组/字符串）也会直接放入老年代
>
> `fullGC`：在老年代和年轻代中发生GC，老年代满了就会触发。fullGC之后内存不足会引起OutOfMemery
>
> //`majorGC`：老年代/方法区



#### 7. 对象的内存布局 

总体分为三个部分：

> 1.对象头：对象存放在堆中，而类的元数据存放在方法区中。对象头是一个指向方法区元数据的指针。可以通过这个指针确认这个对象是哪个类的实例。
>
> 1.1 运行时数据信息：hashcode/分代年龄/锁状态...
>
> 1.2 指向类元信息的指针..
>
> 2.实例数据：
>
> 3.对齐填充



#### 8. 方法区？如何控制方法区大小和解决溢出

> 方法区的大小不固定，JVM可以根据应用，动态确定方法区的大小。
>
> 方法区主要存放：常量/静态变量/类加载器加载的类信息/编译后的代码/运行时常量等

预防溢出：

> 1. 控制Load的class数量
>
> 2. 控制静态变量的数量
> 3. 控制-XX MaxPermSize 大小



#### 9. 溢出类型

> 1. 堆溢出：堆中存放的是对象的实例。一般引起堆溢出的原因是map，list等大对象保持引用。
> 2. 栈溢出：栈中存放的是方法调用的信息。一般引起栈溢出的原因是递归
> 3. 方法区溢出：方法区中存放的是常量/静态变量/类信息/。一般load太多的类会出现permSize问题



#### 10. 